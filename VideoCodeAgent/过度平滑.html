<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Explaining Over-Smoothing</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;500;700&display=swap');

        :root {
            --bg-color: #F8F9FA;
            --text-color: #343A40;
            --text-light-color: #6C757D;
            --accent-color: #007BFF;
            --border-color: #DEE2E6;

            /* Node Colors */
            --color-1: #42a5f5;
            /* Blue */
            --color-2: #ff7043;
            /* Orange */
            --color-3: #66bb6a;
            /* Green */
            --color-4: #ab47bc;
            /* Purple */
            --color-5: #ffee58;
            /* Yellow */
            --color-6: #ef5350;
            /* Red */
            --color-7: #26c6da;
            /* Cyan */
            --final-color: #BDBDBD;
            /* Gray for smoothed state */
        }

        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: var(--bg-color);
            font-family: 'Poppins', 'Helvetica Neue', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', sans-serif;
            overflow: hidden;
        }

        #animation-container {
            width: 2560px;
            height: 1440px;
            position: relative;
            background-color: var(--bg-color);
            transform-origin: center center;
            overflow: hidden;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.1);
            border-radius: 20px;
        }

        #main-svg {
            width: 100%;
            height: 100%;
        }

        .node {
            cursor: pointer;
            transition: filter 0.3s ease;
        }

        .node-circle {
            stroke: rgba(255, 255, 255, 0.8);
            stroke-width: 10px;
        }

        .node:hover {
            filter: brightness(1.1);
        }

        .edge {
            stroke: var(--border-color);
            stroke-width: 6;
            stroke-linecap: round;
        }

        .title-text {
            font-size: 120px;
            font-weight: 700;
            fill: var(--text-color);
            text-anchor: middle;
        }

        .subtitle-text {
            font-size: 60px;
            font-weight: 300;
            fill: var(--text-light-color);
            text-anchor: middle;
        }

        #subtitle-container {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            padding: 20px 40px;
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.05);
            text-align: center;
            opacity: 0;
            visibility: hidden;
        }

        .subtitle-line {
            font-size: 38px;
            line-height: 1.6;
        }

        .subtitle-en {
            color: var(--text-color);
            font-weight: 500;
        }

        .subtitle-zh {
            color: var(--text-light-color);
            font-weight: 300;
        }

        .layer-counter {
            position: absolute;
            top: 80px;
            right: 100px;
            font-size: 70px;
            font-weight: 700;
            color: var(--text-color);
            padding: 20px 40px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 15px;
            opacity: 0;
            visibility: hidden;
        }

        .final-label {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            opacity: 0;
            visibility: hidden;
        }

        .final-label-main {
            font-size: 120px;
            font-weight: 700;
            color: var(--text-color);
        }

        .final-label-sub {
            font-size: 50px;
            font-weight: 300;
            color: var(--text-light-color);
        }

        .classification-visual {
            position: absolute;
            width: 100%;
            height: 100%;
            opacity: 0;
            visibility: hidden;
        }

        .cls-before,
        .cls-after {
            position: absolute;
            width: 50%;
            height: 100%;
            top: 0;
        }

        .cls-before {
            left: 0;
        }

        .cls-after {
            right: 0;
        }

        .cls-title {
            position: absolute;
            top: 150px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 60px;
            font-weight: 500;
            color: var(--text-color);
        }

        .cls-divider {
            position: absolute;
            left: 50%;
            top: 10%;
            bottom: 10%;
            width: 4px;
            background-color: var(--border-color);
        }

        #accuracy-box {
            position: absolute;
            bottom: 300px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 80px;
            font-weight: bold;
            color: var(--color-3);
        }

        #accuracy-value {
            min-width: 200px;
            display: inline-block;
            text-align: left;
        }

        #accuracy-box.failed {
            color: var(--color-6);
        }
    </style>
</head>

<body>
    <div id="animation-container">
        <svg id="main-svg"></svg>

        <div id="subtitle-container">
            <p class="subtitle-line subtitle-en"></p>
            <p class="subtitle-line subtitle-zh"></p>
        </div>

        <div id="layer-counter"></div>

        <div class="final-label">
            <div class="final-label-main">Over-Smoothing</div>
            <div class="final-label-sub">过度平滑</div>
        </div>

        <div class="classification-visual">
            <div class="cls-divider"></div>
            <div class="cls-before">
                <div class="cls-title">Before Smoothing / 平滑前</div>
                <svg id="svg-before" width="100%" height="100%"></svg>
            </div>
            <div class="cls-after">
                <div class="cls-title">After Over-Smoothing / 过度平滑后</div>
                <svg id="svg-after" width="100%" height="100%"></svg>
                <div id="accuracy-box">Accuracy: <span id="accuracy-value">95%</span></div>
            </div>
        </div>

    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script>
        // --- Setup ---
        const container = document.getElementById('animation-container');
        const svg = document.getElementById('main-svg');
        const subtitleContainer = document.getElementById('subtitle-container');
        const subtitleEn = subtitleContainer.querySelector('.subtitle-en');
        const subtitleZh = subtitleContainer.querySelector('.subtitle-zh');
        const layerCounter = document.getElementById('layer-counter');
        const finalLabel = document.querySelector('.final-label');
        const classificationVisual = document.querySelector('.classification-visual');

        const W = 2560;
        const H = 1440;
        const R = 60; // Node radius

        // --- Responsive Scaling ---
        function resize() {
            const ww = window.innerWidth;
            const wh = window.innerHeight;
            const scale = Math.min(ww / W, wh / H);
            container.style.transform = `scale(${scale})`;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- Graph Data ---
        const nodeData = [
            { id: 0, x: W * 0.5, y: H * 0.3, color: 'var(--color-1)' },
            { id: 1, x: W * 0.3, y: H * 0.45, color: 'var(--color-2)' },
            { id: 2, x: W * 0.7, y: H * 0.45, color: 'var(--color-3)' },
            { id: 3, x: W * 0.5, y: H * 0.65, color: 'var(--color-4)' },
            { id: 4, x: W * 0.25, y: H * 0.7, color: 'var(--color-5)' },
            { id: 5, x: W * 0.75, y: H * 0.7, color: 'var(--color-6)' },
            { id: 6, x: W * 0.5, y: H * 0.9, color: 'var(--color-7)' },
        ];

        const edgeData = [
            [0, 1], [0, 2], [0, 3],
            [1, 4],
            [2, 5],
            [3, 1], [3, 2], [3, 6],
            [4, 6], [5, 6]
        ];

        const initialColors = nodeData.map(n => getComputedStyle(document.documentElement).getPropertyValue(n.color.slice(4, -1)));

        // --- SVG Element Creation ---
        const edgeGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        const nodeGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        const particleGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        svg.appendChild(edgeGroup);
        svg.appendChild(nodeGroup);
        svg.appendChild(particleGroup);

        edgeData.forEach(edge => {
            const n1 = nodeData[edge[0]];
            const n2 = nodeData[edge[1]];
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', n1.x);
            line.setAttribute('y1', n1.y);
            line.setAttribute('x2', n2.x);
            line.setAttribute('y2', n2.y);
            line.classList.add('edge');
            edgeGroup.appendChild(line);
        });

        nodeData.forEach(data => {
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.classList.add('node');
            g.setAttribute('id', `node-${data.id}`);
            g.setAttribute('transform', `translate(${data.x}, ${data.y})`);

            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('r', R);
            circle.setAttribute('fill', data.color);
            circle.classList.add('node-circle');

            g.appendChild(circle);
            nodeGroup.appendChild(g);
        });

        const nodes = gsap.utils.toArray(".node");
        const nodeCircles = gsap.utils.toArray(".node-circle");

        // --- Helper Functions ---
        function updateSubtitles(en, zh, duration = 0.5) {
            const tl = gsap.timeline();
            tl.to(subtitleContainer, { autoAlpha: 0, y: 20, duration: duration / 2 })
                .call(() => {
                    subtitleEn.innerHTML = en;
                    subtitleZh.innerHTML = zh;
                })
                .to(subtitleContainer, { autoAlpha: 1, y: 0, duration: duration / 2 });
            return tl;
        }

        function getNeighbors(nodeId) {
            const neighbors = new Set();
            edgeData.forEach(edge => {
                if (edge[0] === nodeId) neighbors.add(edge[1]);
                if (edge[1] === nodeId) neighbors.add(edge[0]);
            });
            return Array.from(neighbors);
        }

        // Color blending function
        function blendColors(colors) {
            let r = 0, g = 0, b = 0;
            colors.forEach(color => {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(color);
                r += parseInt(result[1], 16);
                g += parseInt(result[2], 16);
                b += parseInt(result[3], 16);
            });
            r = Math.floor(r / colors.length);
            g = Math.floor(g / colors.length);
            b = Math.floor(b / colors.length);
            return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
        }


        // --- Main Animation Timeline ---
        const mainTimeline = gsap.timeline({ delay: 1 });

        // Scene 1: Introduction
        const title = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        title.setAttribute('x', W / 2);
        title.setAttribute('y', H / 2 - 50);
        title.classList.add('title-text');
        title.textContent = 'What is Over-Smoothing?';

        const subtitle = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        subtitle.setAttribute('x', W / 2);
        subtitle.setAttribute('y', H / 2 + 50);
        subtitle.classList.add('subtitle-text');
        subtitle.textContent = '什么是过度平滑？';

        svg.appendChild(title);
        svg.appendChild(subtitle);

        mainTimeline
            .from([title, subtitle], { autoAlpha: 0, y: '+=30', duration: 1.5, ease: 'power2.out' })
            .to([title, subtitle], { autoAlpha: 0, y: '-=30', duration: 1, ease: 'power2.in', delay: 1.5 })
            .call(() => {
                svg.removeChild(title);
                svg.removeChild(subtitle);
            });

        // Scene 2: The Graph Appears
        mainTimeline
            .from([...edgeGroup.children, ...nodeGroup.children], { autoAlpha: 0, scale: 0.8, duration: 1, stagger: 0.05, ease: 'back.out(1.7)' })
            .add(updateSubtitles(
                "In a graph, each node holds unique information, like a distinct color.",
                "在图结构中，每个节点都拥有自己独特的信息，就像拥有独特的颜色。"
            ), "-=0.5");

        // Scene 3: GNN Aggregation (1st layer)
        mainTimeline.addLabel("aggregation_start", "+=3");
        mainTimeline.add(updateSubtitles(
            "Graph Neural Networks (GNNs) work by aggregating information from neighbors.",
            "图神经网络 (GNN) 通过聚合邻居节点的信息来学习。"
        ), "aggregation_start");

        mainTimeline.to(layerCounter, { autoAlpha: 1, duration: 0.5, ease: 'power2.out' }, "aggregation_start");
        mainTimeline.call(() => layerCounter.innerText = 'Layer 1 / 第 1 层', [], "aggregation_start");

        nodeData.forEach(node => {
            const neighbors = getNeighbors(node.id);
            const sourceNode = nodeData[node.id];

            neighbors.forEach(neighborId => {
                const neighborNode = nodeData[neighborId];
                const particle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                particle.setAttribute('r', 15);
                particle.setAttribute('fill', getComputedStyle(document.getElementById(`node-${neighborId}`).querySelector('circle')).fill);
                particle.setAttribute('cx', neighborNode.x);
                particle.setAttribute('cy', neighborNode.y);
                particleGroup.appendChild(particle);

                mainTimeline.to(particle, {
                    motionPath: {
                        path: [{ x: neighborNode.x, y: neighborNode.y }, { x: sourceNode.x, y: sourceNode.y }],
                        alignOrigin: [0.5, 0.5]
                    },
                    autoAlpha: 0,
                    duration: 1.5,
                    ease: 'power2.inOut',
                    onComplete: () => particle.remove()
                }, "aggregation_start+=1");
            });
        });

        mainTimeline.add(updateSubtitles(
            "With each layer, a node's representation becomes a blend of itself and its neighbors.",
            "每经过一层，节点就会融合邻居的特征，更新自己。"
        ), "aggregation_start+=2");

        let currentColors = [...initialColors];
        const newColors_L1 = [];

        nodeData.forEach(node => {
            const neighbors = getNeighbors(node.id);
            const selfColor = currentColors[node.id];
            const neighborColors = neighbors.map(id => currentColors[id]);
            const blendedColor = blendColors([selfColor, ...neighborColors]);
            newColors_L1.push(blendedColor);

            mainTimeline.to(nodeCircles[node.id], {
                fill: blendedColor,
                duration: 1,
                ease: 'power2.inOut'
            }, "aggregation_start+=2.5");
        });

        currentColors = newColors_L1;

        // Scene 4: Stacking more layers (The Problem)
        mainTimeline.addLabel("stacking_layers", "+=2");
        mainTimeline.add(updateSubtitles(
            "But what happens when we stack too many layers?",
            "但当我们堆叠过多层时，会发生什么呢？"
        ), "stacking_layers");

        mainTimeline.add(updateSubtitles(
            "As information propagates further...",
            "随着信息在图中不断传播..."
        ), "+=3");

        const finalAvgColor = getComputedStyle(document.documentElement).getPropertyValue('--final-color').trim();
        const smoothingSteps = 5;

        for (let i = 0; i < smoothingSteps; i++) {
            const layerNum = i + 2;
            mainTimeline.call(() => layerCounter.innerText = `Layer ${layerNum} / 第 ${layerNum} 层`, []);

            const newColors = [];
            nodeData.forEach(node => {
                const blendedColor = gsap.utils.interpolate(currentColors[node.id], finalAvgColor, 1 / (smoothingSteps - i + 1));
                newColors.push(blendedColor);
                mainTimeline.to(nodeCircles[node.id], {
                    fill: blendedColor,
                    duration: 0.7,
                    ease: 'none'
                }, "<");
            });
            currentColors = newColors;
            if (i === 1) {
                mainTimeline.add(updateSubtitles(
                    "...the representations of different nodes become increasingly similar.",
                    "...不同节点的特征表达会变得越来越相似。"
                ), ">");
            }
        }

        // Scene 5: The Result - Over-smoothing
        mainTimeline.to(layerCounter, { autoAlpha: 0, duration: 0.5, ease: 'power2.in' }, "+=1");
        mainTimeline.to(nodeCircles, { fill: finalAvgColor, duration: 1, ease: 'power2.inOut' }, ">");

        mainTimeline.add(updateSubtitles(
            "This phenomenon is called Over-Smoothing.",
            "这个现象，就是过度平滑。"
        ), ">-0.5");

        mainTimeline.to(finalLabel, { autoAlpha: 1, scale: 1.1, duration: 0.7, ease: 'back.out(1.7)' }, ">");
        mainTimeline.to(finalLabel, { scale: 1, duration: 0.5 }, ">");

        mainTimeline.add(updateSubtitles(
            "Eventually, all nodes become indistinguishable, losing their unique informative features.",
            "最终，所有节点变得难以区分，失去了它们宝贵的、独特的身份信息。"
        ), "+=2.5");

        // Scene 6: The Consequence
        mainTimeline.to([nodeGroup, edgeGroup, finalLabel], { autoAlpha: 0, duration: 1, ease: 'power2.in' }, "+=3");
        mainTimeline.add(updateSubtitles(
            "This makes downstream tasks like node classification much harder...",
            "这使得下游任务（如节点分类）变得异常困难..."
        ));

        // --- Create Classification Visual ---
        const svgBefore = document.getElementById('svg-before');
        const svgAfter = document.getElementById('svg-after');
        const accuracyBox = document.getElementById('accuracy-box');
        const accuracyValue = document.getElementById('accuracy-value');

        const clsNodeData = [
            // Class A
            { x: 400, y: 500, color: 'var(--color-1)', class: 'A' },
            { x: 550, y: 350, color: 'var(--color-7)', class: 'A' },
            { x: 700, y: 550, color: 'var(--color-4)', class: 'A' },
            // Class B
            { x: 500, y: 900, color: 'var(--color-2)', class: 'B' },
            { x: 750, y: 1000, color: 'var(--color-6)', class: 'B' },
            { x: 850, y: 800, color: 'var(--color-5)', class: 'B' },
        ];

        clsNodeData.forEach(data => {
            const circleBefore = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circleBefore.setAttribute('cx', data.x);
            circleBefore.setAttribute('cy', data.y);
            circleBefore.setAttribute('r', 50);
            circleBefore.setAttribute('fill', data.color);
            svgBefore.appendChild(circleBefore);

            const circleAfter = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circleAfter.setAttribute('cx', data.x);
            circleAfter.setAttribute('cy', data.y);
            circleAfter.setAttribute('r', 50);
            circleAfter.setAttribute('fill', data.color);
            circleAfter.classList.add('cls-after-node');
            svgAfter.appendChild(circleAfter);
        });

        // Classifier line
        const lineBefore = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        lineBefore.setAttribute('x1', 200);
        lineBefore.setAttribute('y1', 720);
        lineBefore.setAttribute('x2', 1080);
        lineBefore.setAttribute('y2', 720);
        lineBefore.setAttribute('stroke', 'var(--accent-color)');
        lineBefore.setAttribute('stroke-width', 8);
        lineBefore.setAttribute('stroke-dasharray', '20 10');
        svgBefore.appendChild(lineBefore);

        const lineAfter = lineBefore.cloneNode();
        lineAfter.id = 'line-after';
        svgAfter.appendChild(lineAfter);

        mainTimeline.to(classificationVisual, { autoAlpha: 1, duration: 1, ease: 'power2.out' });

        mainTimeline.from(svgBefore.childNodes, { scale: 0, transformOrigin: 'center center', stagger: 0.1, duration: 0.8, ease: 'back.out' }, "<");
        mainTimeline.from(svgAfter.childNodes, { scale: 0, transformOrigin: 'center center', stagger: 0.1, duration: 0.8, ease: 'back.out' }, "<");

        mainTimeline.add(updateSubtitles(
            "...as the model can no longer tell the nodes apart.",
            "...因为模型无法再分辨出节点的差异。"
        ), "+=2");

        mainTimeline.to('.cls-after-node', {
            fill: finalAvgColor,
            duration: 1.5,
            stagger: 0.1,
            ease: 'power2.inOut'
        }, ">");

        mainTimeline.to('#line-after', {
            attr: { y1: 300, y2: 1100, 'stroke-dasharray': '5 15' },
            stroke: 'var(--color-6)',
            duration: 0.5,
            repeat: 5,
            yoyo: true,
            ease: 'rough({ template: none.out, strength: 1, points: 20, taper: none, randomize: true, clamp: false})'
        }, ">");

        mainTimeline.to('#accuracy-value', {
            textContent: "50%",
            duration: 1.5,
            ease: 'power1.in',
            onUpdate: function () {
                this.targets()[0].textContent = Math.round(this.progress() * (50 - 95) + 95) + "%";
            },
            onComplete: () => {
                accuracyValue.textContent = "50%";
                accuracyBox.classList.add('failed');
            }
        }, ">-1");

        // Scene 7: Conclusion
        mainTimeline.to([classificationVisual, subtitleContainer], { autoAlpha: 0, duration: 1.5, ease: 'power2.in' }, "+=3");

        const finalTitle = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        finalTitle.setAttribute('x', W / 2);
        finalTitle.setAttribute('y', H / 2 - 30);
        finalTitle.classList.add('title-text');
        finalTitle.style.fontSize = '80px';
        finalTitle.textContent = 'Understanding Over-Smoothing helps build better GNNs.';

        const finalSubtitle = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        finalSubtitle.setAttribute('x', W / 2);
        finalSubtitle.setAttribute('y', H / 2 + 60);
        finalSubtitle.classList.add('subtitle-text');
        finalSubtitle.textContent = '理解过度平滑，帮助我们构建更强大的图神经网络。';

        svg.appendChild(finalTitle);
        svg.appendChild(finalSubtitle);

        mainTimeline.from([finalTitle, finalSubtitle], { autoAlpha: 0, y: '+=30', duration: 1.5, ease: 'power2.out' });

        // Loop animation
        mainTimeline.to({}, { duration: 5, onComplete: () => mainTimeline.restart() });

    </script>
</body>

</html>