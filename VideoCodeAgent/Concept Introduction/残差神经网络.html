<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>残差连接 (Residual Connection) - 动画演示</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&family=Noto+Sans+SC:wght@300;400;700&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --bg-color: #f4f7f6;
            --card-bg: #ffffff;
            --text-main: #2c3e50;
            --text-sub: #7f8c8d;
            --accent-blue: #3498db;
            --accent-purple: #9b59b6;
            --signal-weak: #bdc3c7;
            --signal-strong: #e74c3c;
            --shadow-soft: 0 10px 30px rgba(0, 0, 0, 0.05);
            --font-en: 'Inter', sans-serif;
            --font-cn: 'Noto Sans SC', sans-serif;
        }

        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg-color);
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: var(--font-en);
            overflow: hidden;
        }

        /* 电影舞台容器 */
        #stage {
            width: 960px;
            height: 540px;
            /* 16:9 */
            background: var(--card-bg);
            border-radius: 20px;
            box-shadow: var(--shadow-soft);
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        /* 背景网格装饰 */
        .grid-bg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: radial-gradient(#e0e0e0 1px, transparent 1px);
            background-size: 40px 40px;
            opacity: 0.3;
            z-index: 0;
        }

        /* 标题层 */
        #title-layer {
            position: absolute;
            top: 40px;
            left: 0;
            width: 100%;
            text-align: center;
            z-index: 10;
            opacity: 0;
            transition: opacity 1s ease;
        }

        .main-title {
            font-size: 32px;
            font-weight: 800;
            color: var(--text-main);
            font-family: var(--font-cn);
            margin-bottom: 5px;
        }

        .sub-title {
            font-size: 16px;
            color: var(--text-sub);
            font-weight: 300;
            letter-spacing: 1px;
        }

        /* 核心动画区域 */
        #animation-area {
            position: relative;
            width: 800px;
            height: 300px;
            z-index: 5;
            /* border: 1px dashed #ddd; Debug */
        }

        /* SVG 线条层 */
        svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .path-line {
            fill: none;
            stroke: #ecf0f1;
            stroke-width: 4;
            stroke-linecap: round;
        }

        .active-path {
            fill: none;
            stroke: var(--accent-blue);
            stroke-width: 4;
            stroke-linecap: round;
            stroke-dasharray: 1000;
            stroke-dashoffset: 1000;
            opacity: 0.5;
        }

        /* 节点组件 */
        .node {
            position: absolute;
            background: white;
            border: 2px solid #ecf0f1;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05);
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: 600;
            color: var(--text-main);
            transition: all 0.5s cubic-bezier(0.25, 0.8, 0.25, 1);
            opacity: 0;
            transform: scale(0.8);
        }

        .node.visible {
            opacity: 1;
            transform: scale(1);
        }

        /* 输入输出点 */
        .dot-node {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 14px;
            z-index: 6;
        }

        /* 处理层块 */
        .layer-block {
            width: 140px;
            height: 100px;
            border-radius: 12px;
            flex-direction: column;
            z-index: 6;
            top: 100px;
            /* Center vertically in 300px area */
            left: 330px;
        }

        .layer-block span {
            font-size: 12px;
            color: var(--text-sub);
            margin-top: 4px;
        }

        .layer-block strong {
            font-size: 18px;
            color: var(--accent-purple);
        }

        /* 加法器 */
        .add-node {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            font-size: 24px;
            color: var(--accent-blue);
            border-color: var(--accent-blue);
            z-index: 6;
            top: 125px;
            left: 550px;
        }

        /* 信号球 */
        .signal-ball {
            position: absolute;
            width: 16px;
            height: 16px;
            background: var(--signal-strong);
            border-radius: 50%;
            z-index: 20;
            top: 0;
            left: 0;
            box-shadow: 0 0 10px var(--signal-strong);
            opacity: 0;
        }

        /* 字幕条 */
        #subtitle-box {
            position: absolute;
            bottom: 40px;
            width: 80%;
            text-align: center;
            z-index: 100;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(5px);
            padding: 15px 30px;
            border-radius: 50px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.08);
            transform: translateY(20px);
            opacity: 0;
            transition: all 0.5s ease;
        }

        #subtitle-box.active {
            transform: translateY(0);
            opacity: 1;
        }

        .sub-en {
            display: block;
            font-size: 14px;
            color: var(--text-sub);
            margin-bottom: 4px;
            font-weight: 500;
        }

        .sub-cn {
            display: block;
            font-size: 18px;
            color: var(--text-main);
            font-weight: 700;
            font-family: var(--font-cn);
        }

        /* 公式展示 */
        .formula {
            position: absolute;
            top: 60px;
            right: 60px;
            font-size: 24px;
            font-family: 'Times New Roman', serif;
            font-style: italic;
            color: var(--text-main);
            opacity: 0;
            background: white;
            padding: 10px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
        }

        /* 辅助动画类 */
        .pulse {
            animation: pulse-anim 1s infinite;
        }

        @keyframes pulse-anim {
            0% {
                box-shadow: 0 0 0 0 rgba(52, 152, 219, 0.4);
            }

            70% {
                box-shadow: 0 0 0 10px rgba(52, 152, 219, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(52, 152, 219, 0);
            }
        }

        .fade-in {
            opacity: 1 !important;
        }

        .fade-out {
            opacity: 0 !important;
        }
    </style>
</head>

<body>

    <div id="stage">
        <!-- 背景 -->
        <div class="grid-bg"></div>

        <!-- 标题 -->
        <div id="title-layer">
            <div class="main-title">Residual Connection</div>
            <div class="sub-title">残差连接原理演示</div>
        </div>

        <!-- 公式浮窗 -->
        <div class="formula" id="formula-display">y = F(x) + x</div>

        <!-- 动画主舞台 -->
        <div id="animation-area">
            <!-- SVG路径绘制 -->
            <svg>
                <!-- 主路径: 直线穿过 -->
                <path id="path-main" d="M 100 150 L 330 150 M 470 150 L 550 150 L 700 150" class="path-line" />
                <!-- 捷径: 弧线 -->
                <path id="path-skip" d="M 180 150 Q 400 20 575 130" class="active-path"
                    style="opacity:0; stroke-dashoffset: 500;" />
                <!-- 辅助连线 -->
                <line x1="575" y1="130" x2="575" y2="150" stroke="#3498db" stroke-width="2" style="opacity:0"
                    id="line-connector" />
            </svg>

            <!-- HTML 节点元素 -->
            <!-- 输入 x -->
            <div class="node dot-node" style="top: 130px; left: 80px;" id="node-input">x</div>

            <!-- 权重层 F(x) -->
            <div class="node layer-block" id="node-layer">
                <strong>Weight Layer</strong>
                <span>F(x) transformation</span>
            </div>

            <!-- 加法器 + -->
            <div class="node add-node" id="node-add">+</div>

            <!-- 输出 y -->
            <div class="node dot-node" style="top: 130px; left: 680px;" id="node-output">y</div>

            <!-- 动态的小球 -->
            <div class="signal-ball" id="ball-main"></div>
            <div class="signal-ball" id="ball-skip" style="background-color: var(--accent-blue);"></div>
        </div>

        <!-- 字幕 -->
        <div id="subtitle-box">
            <span class="sub-en"></span>
            <span class="sub-cn"></span>
        </div>
    </div>

    <script>
        // 工具函数：等待
        const wait = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        // 获取元素
        const els = {
            title: document.getElementById('title-layer'),
            subBox: document.getElementById('subtitle-box'),
            subEn: document.querySelector('.sub-en'),
            subCn: document.querySelector('.sub-cn'),
            nodeInput: document.getElementById('node-input'),
            nodeLayer: document.getElementById('node-layer'),
            nodeAdd: document.getElementById('node-add'),
            nodeOutput: document.getElementById('node-output'),
            ballMain: document.getElementById('ball-main'),
            ballSkip: document.getElementById('ball-skip'),
            pathSkip: document.getElementById('path-skip'),
            connector: document.getElementById('line-connector'),
            formula: document.getElementById('formula-display')
        };

        // 字幕控制
        async function showSubtitle(en, cn, duration = 2000) {
            els.subEn.textContent = en;
            els.subCn.textContent = cn;
            els.subBox.classList.add('active');
            await wait(duration);
            if (duration > 0) {
                els.subBox.classList.remove('active');
                await wait(500); // 字幕切换缓冲
            }
        }

        // 动画主逻辑
        async function playAnimation() {
            await wait(500);

            // --- 场景 1: 开场 ---
            els.title.style.opacity = 1;
            await showSubtitle("Welcome to the concept of Residual Connection.", "欢迎了解“残差连接”的概念。", 3000);

            // 展示基本结构
            els.nodeInput.classList.add('visible');
            await wait(300);
            els.nodeLayer.classList.add('visible');
            await wait(300);
            els.nodeOutput.classList.add('visible');

            await showSubtitle("In deep neural networks, information passes through layers.", "在深度神经网络中，信息需要穿过层层网络。", 3000);

            // --- 场景 2: 问题展示 (普通网络) ---
            await showSubtitle("However, as networks get deeper, the signal can degrade.", "然而，随着网络变深，信号可能会衰退或丢失。", 1000);

            // 动画：信号穿过层，变弱
            els.ballMain.style.opacity = 1;
            els.ballMain.style.transition = 'none';
            els.ballMain.style.transform = `translate(100px, 150px)`; // Start at x

            // 移动到 Layer
            await animateBall(els.ballMain, 100, 150, 330, 150, 1000);

            // 穿过 Layer (变色变小表示处理/损耗)
            els.nodeLayer.classList.add('pulse');
            await animateBall(els.ballMain, 330, 150, 470, 150, 800);
            els.ballMain.style.backgroundColor = '#bdc3c7'; // 变灰
            els.ballMain.style.transform += ' scale(0.5)'; // 变小
            els.nodeLayer.classList.remove('pulse');

            // 移动到 Output
            await animateBall(els.ballMain, 470, 150, 700, 150, 1000);

            await showSubtitle("This degradation makes deep networks hard to train.", "这种退化现象使得深度网络难以训练。", 3000);

            // 重置球
            els.ballMain.style.opacity = 0;
            els.ballMain.style.backgroundColor = 'var(--signal-strong)';
            els.ballMain.style.transform = 'scale(1)';

            // --- 场景 3: 引入残差连接 (The Bridge) ---
            await showSubtitle("The solution? Add a 'Shortcut' connection.", "解决方案是什么？添加一条“捷径”。", 2500);

            // 画出曲线
            els.pathSkip.style.opacity = 1;
            els.pathSkip.style.transition = 'stroke-dashoffset 2s ease-in-out';
            els.pathSkip.style.strokeDashoffset = 0;
            await wait(2000);

            // 显示加法器
            els.connector.style.opacity = 1; // 辅助线
            els.nodeAdd.classList.add('visible');

            await showSubtitle("This allows the original signal to bypass the layers.", "这允许原始信号直接跳过中间的处理层。", 3000);

            // --- 场景 4: 完整流程演示 ---
            await showSubtitle("Let's watch the signal flow in a Residual Block.", "让我们看看残差块中的信号流动。", 1000);

            // 1. 准备两个球
            els.ballMain.style.opacity = 1;
            els.ballSkip.style.opacity = 0;

            // 移动到分叉点 (假设在 x 后一点点分叉)
            els.ballMain.style.transition = 'none';
            els.ballMain.style.transform = `translate(100px, 150px)`;
            await animateBall(els.ballMain, 100, 150, 180, 150, 500); // 到达分叉点

            // 分叉
            els.ballSkip.style.opacity = 1;
            els.ballSkip.style.transform = `translate(180px, 150px)`;

            await showSubtitle("The input x splits into two paths.", "输入 x 分为两路。", 2000);

            // 并行执行动画
            const p1 = (async () => {
                // 主路：经过层 F(x)
                await animateBall(els.ballMain, 180, 150, 330, 150, 800); // To layer
                els.nodeLayer.classList.add('pulse');
                await wait(200);
                // 经过变换，颜色变一点
                els.ballMain.style.backgroundColor = '#9b59b6'; // Purple
                await animateBall(els.ballMain, 330, 150, 550, 150, 800); // To Add node
                els.nodeLayer.classList.remove('pulse');
            })();

            const p2 = (async () => {
                // 捷径：走弧线 (Identity)
                // 使用简单的贝塞尔曲线插值模拟
                const start = { x: 180, y: 150 };
                const control = { x: 400, y: 20 };
                const end = { x: 575, y: 130 };
                const steps = 60;
                for (let i = 0; i <= steps; i++) {
                    const t = i / steps;
                    // 二次贝塞尔公式
                    const x = (1 - t) * (1 - t) * start.x + 2 * (1 - t) * t * control.x + t * t * end.x;
                    const y = (1 - t) * (1 - t) * start.y + 2 * (1 - t) * t * control.y + t * t * end.y;
                    els.ballSkip.style.transform = `translate(${x}px, ${y}px)`;
                    await wait(1600 / steps); // 总时长约1.6s
                }
                // Drop down to +
                await animateBall(els.ballSkip, 575, 130, 575, 150, 200);
                // Adjust to center of +
                await animateBall(els.ballSkip, 575, 150, 550, 150, 200);
            })();

            await Promise.all([p1, p2]);

            // --- 场景 5: 融合 ---
            await showSubtitle("F(x) and x are added together element-wise.", "变换后的 F(x) 与原始 x 逐元素相加。", 3000);

            // 融合动画
            els.nodeAdd.classList.add('pulse');
            els.ballSkip.style.opacity = 0; // 消失
            els.ballMain.style.transform = `translate(550px, 150px) scale(1.3)`; // 变大
            els.ballMain.style.backgroundColor = 'var(--signal-strong)'; // 恢复强信号色
            els.ballMain.style.boxShadow = '0 0 20px var(--signal-strong)';
            await wait(500);
            els.nodeAdd.classList.remove('pulse');

            // 输出
            await animateBall(els.ballMain, 550, 150, 700, 150, 1000);

            // --- 场景 6: 总结 ---
            els.formula.classList.add('fade-in');

            await showSubtitle("The output y contains both the new features and original info.", "输出 y 既包含了新特征，又保留了原始信息。", 3000);

            await showSubtitle("This simple trick enabled the deep learning revolution.", "这一简单的技巧开启了深度学习的革命。", 4000);

            // 结束定格
            els.subBox.classList.remove('active');
            await wait(1000);

            // 循环提示
            // showSubtitle("Replaying...", "即将重播...", 2000);
            // await wait(2000);
            // location.reload(); 
        }

        // 简单的线性插值动画函数
        function animateBall(element, startX, startY, endX, endY, duration) {
            return new Promise(resolve => {
                const startTime = performance.now();

                function step(currentTime) {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / duration, 1);

                    // Ease function (easeInOutQuad)
                    const ease = progress < .5 ? 2 * progress * progress : -1 + (4 - 2 * progress) * progress;

                    const currentX = startX + (endX - startX) * ease;
                    const currentY = startY + (endY - startY) * ease;

                    element.style.transform = `translate(${currentX}px, ${currentY}px)`;

                    if (progress < 1) {
                        requestAnimationFrame(step);
                    } else {
                        resolve();
                    }
                }
                requestAnimationFrame(step);
            });
        }

        // 启动
        window.onload = playAnimation;

    </script>
</body>

</html>