<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flow Matching Explained</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <style>
        :root {
            --bg-color: #f4f7f9;
            --primary-text: #2c3e50;
            --secondary-text: #7f8c8d;
            --accent-color-1: #3498db;
            --accent-color-2: #e74c3c;
            --accent-color-3: #2ecc71;
            --accent-color-4: #f39c12;
            --container-width: 2560px;
            --container-height: 1440px;
        }

        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap');

        body {
            margin: 0;
            font-family: 'Poppins', sans-serif;
            background-color: var(--bg-color);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        #animation-container {
            position: relative;
            width: var(--container-width);
            height: var(--container-height);
            background-color: #ffffff;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.08);
            border-radius: 20px;
            overflow: hidden;
            transform-origin: top left;
        }

        #main-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .title-text {
            font-size: 120px;
            font-weight: 600;
            fill: var(--primary-text);
        }

        .subtitle-text {
            font-size: 50px;
            font-weight: 300;
            fill: var(--secondary-text);
        }

        .label-text {
            font-size: 42px;
            font-weight: 400;
            fill: var(--primary-text);
            text-anchor: middle;
        }

        .code-text {
            font-family: 'Courier New', Courier, monospace;
            font-size: 38px;
            fill: var(--secondary-text);
            text-anchor: middle;
        }

        .point-p0 {
            fill: var(--accent-color-1);
        }

        .point-p1 {
            fill: var(--accent-color-2);
        }

        .flow-line {
            stroke: var(--accent-color-1);
            stroke-opacity: 0.2;
            stroke-width: 2;
        }

        .vector-arrow {
            stroke-width: 8;
        }

        .nn-node {
            fill: #fff;
            stroke-width: 5;
        }

        .nn-connection {
            stroke: var(--primary-text);
            stroke-opacity: 0.2;
            stroke-width: 2;
        }

        #subtitle-box {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            padding: 25px 40px;
            background-color: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.05);
            text-align: center;
            z-index: 100;
        }

        #subtitle-zh {
            font-size: 38px;
            color: var(--primary-text);
            font-weight: 600;
            margin: 0 0 10px 0;
        }

        #subtitle-en {
            font-size: 28px;
            color: var(--secondary-text);
            margin: 0;
        }

        /* Responsive Scaling */
        @media (max-width: 2560px) {
            #animation-container {
                width: 100vw;
                height: 56.25vw;
                /* 16:9 aspect ratio */
            }
        }

        @media (max-height: 1440px) {
            #animation-container {
                height: 100vh;
                width: 177.78vh;
                /* 16:9 aspect ratio */
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
            }
        }
    </style>
</head>

<body>

    <div id="animation-container">
        <svg id="main-svg" viewBox="0 0 2560 1440">
            <!-- Background Elements -->
            <g id="background-grid">
                <!-- Grid lines will be generated by JS -->
            </g>

            <!-- Scene 1: Title -->
            <g id="scene1-title" opacity="0">
                <text x="1280" y="650" class="title-text" text-anchor="middle">Flow Matching</text>
                <text x="1280" y="760" class="subtitle-text" text-anchor="middle">流量匹配</text>
            </g>

            <!-- Scene 2 & 3: Distributions & Flow -->
            <g id="scene2-distributions">
                <g id="p0-container" opacity="0">
                    <text x="600" y="250" class="label-text">P₀: Simple Distribution</text>
                    <text x="600" y="300" class="code-text">(e.g., Gaussian Noise)</text>
                    <g id="p0-points"></g>
                </g>
                <g id="p1-container" opacity="0">
                    <text x="1960" y="250" class="label-text">P₁: Target Distribution</text>
                    <text x="1960" y="300" class="code-text">(e.g., Real Data)</text>
                    <g id="p1-points"></g>
                </g>
                <g id="flow-lines" opacity="0"></g>
            </g>

            <!-- Scene 4: Time Evolution -->
            <g id="scene4-time" opacity="0">
                <rect x="740" y="1250" width="1080" height="10" fill="#e0e0e0" rx="5" />
                <rect id="time-progress" x="740" y="1250" width="0" height="10" fill="var(--accent-color-3)" rx="5" />
                <text x="740" y="1310" class="label-text" text-anchor="middle">t = 0</text>
                <text x="1820" y="1310" class="label-text" text-anchor="middle">t = 1</text>
                <text id="time-label" x="1280" y="1220" class="label-text" text-anchor="middle" font-size="48px"
                    font-weight="600" fill="var(--accent-color-3)"></text>
            </g>

            <!-- Scene 5: Neural Network -->
            <g id="scene5-nn" opacity="0">
                <defs>
                    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="0" refY="3.5" orient="auto">
                        <polygon points="0 0, 10 3.5, 0 7" fill="var(--primary-text)" />
                    </marker>
                </defs>
                <g id="nn-structure" transform="translate(1280, 720) scale(1.2)">
                    <rect x="-150" y="-200" width="300" height="400" rx="20" fill="#ffffff" stroke="var(--primary-text)"
                        stroke-width="5" stroke-opacity="0.2" />
                    <text x="0" y="-140" text-anchor="middle" class="label-text" font-size="36px">Neural Network</text>
                    <text x="0" y="-100" text-anchor="middle" class="code-text" font-size="30px">v(x, t)</text>

                    <!-- Nodes -->
                    <circle cx="-100" cy="-50" r="15" class="nn-node" stroke="var(--accent-color-4)" />
                    <circle cx="-100" cy="50" r="15" class="nn-node" stroke="var(--accent-color-4)" />

                    <circle cx="0" cy="-80" r="15" class="nn-node" stroke="var(--primary-text)" />
                    <circle cx="0" cy="0" r="15" class="nn-node" stroke="var(--primary-text)" />
                    <circle cx="0" cy="80" r="15" class="nn-node" stroke="var(--primary-text)" />

                    <circle cx="100" cy="0" r="15" class="nn-node" stroke="var(--accent-color-3)" />

                    <!-- Connections -->
                    <path class="nn-connection" d="M -100 -50 L 0 -80 M -100 -50 L 0 0 M -100 -50 L 0 80" />
                    <path class="nn-connection" d="M -100 50 L 0 -80 M -100 50 L 0 0 M -100 50 L 0 80" />
                    <path class="nn-connection" d="M 0 -80 L 100 0 M 0 0 L 100 0 M 0 80 L 100 0" />
                </g>
                <text id="nn-input-label" x="980" y="680" class="code-text" text-anchor="end">Input: (x , t)</text>
                <line id="nn-input-arrow" x1="1000" y1="720" x2="1100" y2="720" stroke="var(--accent-color-4)"
                    stroke-width="6" marker-end="url(#arrowhead)" />

                <text id="nn-output-label" x="1580" y="680" class="code-text" text-anchor="start">Output: Velocity
                    v</text>
                <line id="nn-output-arrow" x1="1460" y1="720" x2="1560" y2="720" stroke="var(--accent-color-3)"
                    stroke-width="6" marker-end="url(#arrowhead)" />
            </g>

            <!-- Scene 6: Matching -->
            <g id="scene6-matching" opacity="0">
                <circle id="matching-point" r="15" fill="var(--accent-color-4)" stroke="#fff" stroke-width="4"></circle>
                <line id="vector-u" class="vector-arrow" stroke="var(--accent-color-1)" marker-end="url(#arrowhead)" />
                <line id="vector-v" class="vector-arrow" stroke="var(--accent-color-3)" marker-end="url(#arrowhead)" />
                <text id="label-u" x="0" y="0" class="code-text" fill="var(--accent-color-1)">Target u(x, t)</text>
                <text id="label-v" x="0" y="0" class="code-text" fill="var(--accent-color-3)">Predicted v(x, t)</text>

                <g id="loss-group" transform="translate(1280, 1000)">
                    <text text-anchor="middle" class="label-text" font-size="60px">Loss = || u - v ||²</text>
                    <text text-anchor="middle" y="60" class="subtitle-text" font-size="40px">Minimize the
                        difference</text>
                </g>
            </g>

            <!-- Scene 7: Generation -->
            <g id="scene7-generation">
                <g id="gen-points"></g>
                <g id="trained-nn" opacity="0" transform="translate(1280, 150) scale(0.6)">
                    <rect x="-150" y="-120" width="300" height="240" rx="20" fill="#e8f5e9"
                        stroke="var(--accent-color-3)" stroke-width="5" />
                    <text x="0" y="-50" text-anchor="middle" class="label-text" font-size="36px">Trained Network</text>
                    <path fill="var(--accent-color-3)" d="M-40,0 L-10,-30 L-10,-10 L40,-10 L40,10 L-10,10 L-10,30 Z" />
                </g>
            </g>

        </svg>

        <div id="subtitle-box">
            <p id="subtitle-zh"></p>
            <p id="subtitle-en"></p>
        </div>
    </div>

    <script>
        const svgNS = "http://www.w3.org/2000/svg";
        const mainSVG = document.getElementById('main-svg');
        const p0PointsGroup = document.getElementById('p0-points');
        const p1PointsGroup = document.getElementById('p1-points');
        const flowLinesGroup = document.getElementById('flow-lines');

        const NUM_POINTS = 80;
        const WIDTH = 2560;
        const HEIGHT = 1440;

        const p0_center_x = 600, p0_center_y = 720;
        const p1_center_x = 1960, p1_center_y = 720;

        let p0_coords = [];
        let p1_coords = [];
        let p0_elements = [];
        let flow_line_elements = [];

        // 1. Generate Data Points
        function generateGaussianPoints(n, cx, cy, scale) {
            const points = [];
            for (let i = 0; i < n; i++) {
                let u = 0, v = 0;
                while (u === 0) u = Math.random();
                while (v === 0) v = Math.random();
                let x = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
                let y = Math.sqrt(-2.0 * Math.log(u)) * Math.sin(2.0 * Math.PI * v);
                points.push({ x: cx + x * scale, y: cy + y * scale });
            }
            return points;
        }

        function generateSpiralPoints(n, cx, cy, scale) {
            const points = [];
            const a = 0;
            const b = 15;
            for (let i = 0; i < n; i++) {
                const angle = 0.2 * i;
                const radius = (a + b * angle) * scale / 100;
                const x = cx + radius * Math.cos(angle) + (Math.random() - 0.5) * 25;
                const y = cy + radius * Math.sin(angle) + (Math.random() - 0.5) * 25;
                points.push({ x, y });
            }
            return points;
        }

        p0_coords = generateGaussianPoints(NUM_POINTS, p0_center_x, p0_center_y, 150);
        p1_coords = generateSpiralPoints(NUM_POINTS, p1_center_x, p1_center_y, 150);

        // 2. Create SVG Elements
        p0_coords.forEach((p, i) => {
            const circle = document.createElementNS(svgNS, 'circle');
            circle.setAttribute('cx', p.x);
            circle.setAttribute('cy', p.y);
            circle.setAttribute('r', 8);
            circle.setAttribute('class', 'point-p0');
            p0PointsGroup.appendChild(circle);
            p0_elements.push(circle);

            const p1 = p1_coords[i];
            const p1_circle = document.createElementNS(svgNS, 'circle');
            p1_circle.setAttribute('cx', p1.x);
            p1_circle.setAttribute('cy', p1.y);
            p1_circle.setAttribute('r', 8);
            p1_circle.setAttribute('class', 'point-p1');
            p1PointsGroup.appendChild(p1_circle);

            const line = document.createElementNS(svgNS, 'line');
            line.setAttribute('x1', p.x);
            line.setAttribute('y1', p.y);
            line.setAttribute('x2', p1.x);
            line.setAttribute('y2', p1.y);
            line.setAttribute('class', 'flow-line');
            flowLinesGroup.appendChild(line);
            flow_line_elements.push(line);
        });

        // Generate background grid
        const gridGroup = document.getElementById('background-grid');
        for (let i = 1; i < 20; i++) {
            const line = document.createElementNS(svgNS, 'line');
            line.setAttribute('x1', i * WIDTH / 20);
            line.setAttribute('y1', 0);
            line.setAttribute('x2', i * WIDTH / 20);
            line.setAttribute('y2', HEIGHT);
            line.setAttribute('stroke', '#000');
            line.setAttribute('stroke-opacity', '0.04');
            gridGroup.appendChild(line);
        }
        for (let i = 1; i < 12; i++) {
            const line = document.createElementNS(svgNS, 'line');
            line.setAttribute('x1', 0);
            line.setAttribute('y1', i * HEIGHT / 12);
            line.setAttribute('x2', WIDTH);
            line.setAttribute('y2', i * HEIGHT / 12);
            line.setAttribute('stroke', '#000');
            line.setAttribute('stroke-opacity', '0.04');
            gridGroup.appendChild(line);
        }


        // 3. Subtitles Data
        const subtitles = [
            { t: 0.5, zh: "如何让机器生成像这样复杂的全新数据？", en: "How can we teach a machine to generate complex, new data?" },
            { t: 3.5, zh: "Flow Matching (流量匹配) 提供了一种优雅而强大的解决方案。", en: "Flow Matching offers an elegant and powerful solution." },
            { t: 7.5, zh: "我们的目标，是从一个简单的分布 P₀...", en: "Our goal is to transform a simple distribution, P₀..." },
            { t: 10.5, zh: "...学习生成一个复杂的目标分布 P₁。", en: "...and learn to generate a complex target distribution, P₁." },
            { t: 14, zh: "想象一下，每个点都有一条从起点到终点的路径。", en: "Imagine each point has a path from its start to its end." },
            { t: 17, zh: "这些路径共同构成了一个“矢量场”或“流”。", en: "Together, these paths form a 'vector field' or a 'flow'." },
            { t: 21, zh: "这个转变不是瞬间的，它发生在一个从0到1的连续时间't'上。", en: "This transformation is not instant. It happens over a continuous time 't' from 0 to 1." },
            { t: 25, zh: "当 t=0 时，所有点都在初始位置。", en: "At t=0, all points are at their initial positions." },
            { t: 29, zh: "随着't'的增加，点沿着路径平滑移动。", en: "As 't' increases, the points move smoothly along their paths." },
            { t: 33, zh: "当 t=1 时，它们就形成了目标分布。", en: "At t=1, they form the target distribution." },
            { t: 37, zh: "我们的核心任务，是训练一个神经网络来学习这个流动的“速度”。", en: "Our core task is to train a neural network to learn the 'velocity' of this flow." },
            { t: 41.5, zh: "神经网络的输入是任意点的位置 x 和当前时间 t。", en: "The network takes a point's position x and the current time t as input." },
            { t: 45, zh: "它的输出是该点在该时刻应该具有的速度矢量 v。", en: "It outputs the velocity vector v that the point should have at that moment." },
            { t: 49.5, zh: "这就是“匹配”的由来：我们让网络预测的速度 v...", en: "This is where 'matching' comes in: we make the network's predicted velocity v..." },
            { t: 53.5, zh: "...去匹配一个我们预先定义的、简单的目标速度 u。", en: "...match a pre-defined, simple target velocity u." },
            { t: 58, zh: "我们通过最小化它们之间的差异（损失）来训练网络。", en: "We train the network by minimizing the difference (loss) between them." },
            { t: 62.5, zh: "训练完成后，神奇的事情发生了：我们可以开始生成！", en: "Once trained, the magic happens: we can start generating!" },
            { t: 66, zh: "我们从简单分布中取一个全新的随机点...", en: "We take a brand new random point from the simple distribution..." },
            { t: 70, zh: "...然后使用我们训练好的网络，一步步引导它前进。", en: "...and use our trained network to guide it, step by step." },
            { t: 74, zh: "网络在每一步都计算出正确的方向和速度。", en: "The network calculates the correct direction and speed at each step." },
            { t: 78, zh: "最终，这个点会平滑地流入目标分布，形成一个全新的样本。", en: "Eventually, the point flows smoothly into the target distribution, creating a brand new sample." },
            { t: 84, zh: "这就是Flow Matching：稳定、高效地学习从噪声到数据的直接映射。", en: "This is Flow Matching: a stable and efficient way to learn a direct map from noise to data." },
        ];

        const subtitleZh = document.getElementById('subtitle-zh');
        const subtitleEn = document.getElementById('subtitle-en');
        function updateSubtitles(zh, en) {
            gsap.to([subtitleZh, subtitleEn], {
                opacity: 0, duration: 0.3, onComplete: () => {
                    subtitleZh.textContent = zh;
                    subtitleEn.textContent = en;
                    gsap.to([subtitleZh, subtitleEn], { opacity: 1, duration: 0.3 });
                }
            });
        }

        // 4. GSAP Animation Timeline
        const tl = gsap.timeline({ delay: 1 });

        // Add subtitles to timeline
        subtitles.forEach(sub => {
            tl.call(updateSubtitles, [sub.zh, sub.en], sub.t);
        });

        // Scene 1: Title
        tl.to("#scene1-title", { opacity: 1, duration: 1.5, ease: "power2.inOut" }, 0)
            .to("#scene1-title", { opacity: 0, duration: 1.5, ease: "power2.inOut" }, 5);

        // Scene 2: Show distributions
        tl.to("#p0-container", { opacity: 1, duration: 1.5 }, 7)
            .to("#p1-container", { opacity: 1, duration: 1.5 }, 9.5);

        // Scene 3: Show flow lines
        tl.from(flow_line_elements, {
            strokeDasharray: 1500,
            strokeDashoffset: 1500,
            duration: 2,
            ease: "power1.inOut",
            stagger: 0.02
        }, 15)
            .to("#flow-lines", { opacity: 1, duration: 0.1 }, 15);

        // Scene 4: Animate points moving
        tl.addLabel("time-evolution", 24)
            .to("#flow-lines", { opacity: 0.1, duration: 1 }, "time-evolution")
            .to("#scene4-time", { opacity: 1, duration: 1 }, "time-evolution")
            .to(p0_elements, {
                cx: (i) => p1_coords[i].x,
                cy: (i) => p1_coords[i].y,
                duration: 8,
                ease: "sine.inOut",
                stagger: {
                    each: 0.01,
                    from: "random"
                },
                onUpdate: function () {
                    const progress = this.progress();
                    gsap.set("#time-progress", { attr: { width: 1080 * progress } });
                    gsap.set("#time-label", { textContent: `t = ${progress.toFixed(2)}` });
                }
            }, "time-evolution+=1")
            .set("#time-label", { textContent: "" }); // Clear label after animation

        // Hide scene elements for next scene
        tl.to(["#p0-container", "#p1-container", "#scene4-time"], { opacity: 0, duration: 1 }, 35)
            .to(p0_elements, { opacity: 0, duration: 1 }, 35);

        // Reset points to start for next explanation
        tl.set(p0_elements, {
            cx: (i) => p0_coords[i].x,
            cy: (i) => p0_coords[i].y,
            opacity: 1
        });

        // Scene 5: Neural Network
        tl.addLabel("nn-reveal", 37.5)
            .to("#scene5-nn", { opacity: 1, duration: 1.5 }, "nn-reveal")
            .from("#nn-structure", { scale: 0.5, opacity: 0, duration: 1.5, ease: "back.out(1.7)" }, "nn-reveal")
            .from(["#nn-input-label", "#nn-input-arrow"], { x: '+=100', opacity: 0, duration: 1, stagger: 0.2 }, "nn-reveal+=1.5")
            .from(["#nn-output-label", "#nn-output-arrow"], { x: '-=100', opacity: 0, duration: 1, stagger: 0.2 }, "nn-reveal+=2.5")
            .to("#scene5-nn", { opacity: 0, duration: 1 }, 48);

        // Scene 6: Matching
        const matchingPointIndex = Math.floor(NUM_POINTS / 2);
        const p_start = p0_coords[matchingPointIndex];
        const p_end = p1_coords[matchingPointIndex];
        const p_mid = { x: (p_start.x + p_end.x) / 2, y: (p_start.y + p_end.y) / 2 };

        const vector_u_end = { x: p_mid.x + (p_end.x - p_start.x) * 0.3, y: p_mid.y + (p_end.y - p_start.y) * 0.3 };
        // Let predicted vector v be slightly different initially
        const vector_v_end_initial = { x: p_mid.x + (p_end.x - p_start.x) * 0.35, y: p_mid.y + (p_end.y - p_start.y) * 0.2 };

        tl.addLabel("matching-scene", 49)
            .set("#matching-point", { attr: { cx: p_mid.x, cy: p_mid.y } })
            .set("#vector-u", { attr: { x1: p_mid.x, y1: p_mid.y, x2: p_mid.x, y2: p_mid.y } })
            .set("#vector-v", { attr: { x1: p_mid.x, y1: p_mid.y, x2: p_mid.x, y2: p_mid.y } })
            .set("#label-u", { attr: { x: vector_u_end.x + 20, y: vector_u_end.y } })
            .set("#label-v", { attr: { x: vector_v_end_initial.x + 20, y: vector_v_end_initial.y } })
            .to("#scene6-matching", { opacity: 1, duration: 1 }, "matching-scene")
            .to("#vector-u", { attr: { x2: vector_u_end.x, y2: vector_u_end.y }, duration: 1, ease: "power2.out" }, "matching-scene+=1")
            .to("#vector-v", { attr: { x2: vector_v_end_initial.x, y2: vector_v_end_initial.y }, duration: 1, ease: "power2.out" }, "matching-scene+=1.5")
            .from("#loss-group", { opacity: 0, y: "+=50", duration: 1 }, "matching-scene+=3")
            // Animate v matching u
            .to("#vector-v", { attr: { x2: vector_u_end.x, y2: vector_u_end.y }, duration: 1.5, ease: "elastic.out(1, 0.5)" }, "matching-scene+=4.5")
            .to("#label-v", { attr: { x: vector_u_end.x + 20, y: vector_u_end.y + 40 }, duration: 1.5, ease: "elastic.out(1, 0.5)" }, "matching-scene+=4.5")
            .to("#loss-group", { scale: 0.8, opacity: 0.5, duration: 1.5, ease: "power2.in" }, "matching-scene+=4.5")
            .to("#scene6-matching", { opacity: 0, duration: 1 }, 61);

        // Scene 7: Generation
        tl.addLabel("generation-scene", 62)
            .to("#p1-container", { opacity: 0.2, duration: 1 }, "generation-scene") // Show ghost of target
            .to("#trained-nn", { opacity: 1, duration: 1 }, "generation-scene+=1")

        // Animate a few points being generated
        function createGenerationAnimation(startTime, pointIndex) {
            const start = p0_coords[pointIndex];
            const end = p1_coords[pointIndex];

            const genPoint = document.createElementNS(svgNS, 'circle');
            genPoint.setAttribute('r', 12);
            genPoint.setAttribute('class', 'point-p0');
            genPoint.setAttribute('fill', 'var(--accent-color-3)');
            genPoint.setAttribute('stroke', '#fff');
            genPoint.setAttribute('stroke-width', '4');
            document.getElementById('gen-points').appendChild(genPoint);

            tl.set(genPoint, { attr: { cx: start.x, cy: start.y }, opacity: 1 }, startTime)
                .to(genPoint, {
                    duration: 4,
                    ease: "power1.inOut",
                    motionPath: {
                        path: [{ x: start.x, y: start.y }, { x: (start.x + end.x) / 2 + (Math.random() - 0.5) * 200, y: (start.y + end.y) / 2 + (Math.random() - 0.5) * 200 }, { x: end.x, y: end.y }],
                        curviness: 1,
                    }
                }, startTime + 0.5)
                .to(genPoint, {
                    attr: { r: 8 },
                    fill: 'var(--accent-color-2)',
                    duration: 0.5
                }, startTime + 4.5);
        }

        createGenerationAnimation("generation-scene+=2", 10);
        createGenerationAnimation("generation-scene+=4", 30);
        createGenerationAnimation("generation-scene+=6", 50);
        createGenerationAnimation("generation-scene+=8", 70);

        // Final scene
        tl.to(["#p1-container", "#trained-nn", "#gen-points"], { opacity: 0, duration: 1.5 }, 83)
            .set("#scene1-title text:nth-child(1)", { textContent: "Flow Matching" })
            .set("#scene1-title text:nth-child(2)", { textContent: "Simple, Stable, Powerful" })
            .to("#scene1-title", { opacity: 1, duration: 2, ease: "power2.inOut" }, 85)

        // Initial setup for subtitles
        updateSubtitles("", "");

        // Resize handler
        function handleResize() {
            const container = document.getElementById('animation-container');
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            const nativeRatio = 2560 / 1440;
            const windowRatio = windowWidth / windowHeight;

            if (windowRatio > nativeRatio) {
                // Window is wider than content
                container.style.width = windowHeight * nativeRatio + 'px';
                container.style.height = windowHeight + 'px';
            } else {
                // Window is taller than content
                container.style.width = windowWidth + 'px';
                container.style.height = windowWidth / nativeRatio + 'px';
            }
            container.style.left = '50%';
            container.style.top = '50%';
            container.style.transform = 'translate(-50%, -50%)';
        }

        // This is a simplified resize for the demo. For a perfect fit, a more robust solution might be needed.
        // For this self-contained example, we'll let the @media queries handle it, as they work well.
        // window.addEventListener('resize', handleResize);
        // handleResize();

    </script>
</body>

</html>