<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>卷积神经网络原理可视化 | CNN Explained</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&family=Noto+Sans+SC:wght@300;400;700&display=swap');

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #f9fafb; /* 极浅的灰白色 */
            overflow: hidden;
            font-family: 'Inter', 'Noto Sans SC', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #container {
            position: relative;
            width: 1280px; /* 固定画布比例 16:9 */
            height: 720px;
            background: #ffffff;
            box-shadow: 0 20px 50px rgba(0,0,0,0.05);
            border-radius: 12px;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* 字幕区域 */
        .subtitle-container {
            position: absolute;
            bottom: 60px;
            left: 0;
            width: 100%;
            text-align: center;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }

        .subtitle-cn {
            font-size: 24px;
            font-weight: 700;
            color: #1f2937;
            margin-bottom: 8px;
            text-shadow: 0 2px 4px rgba(255,255,255,0.8);
        }

        .subtitle-en {
            font-size: 16px;
            font-weight: 400;
            color: #6b7280;
            letter-spacing: 0.5px;
        }

        /* 进度条 */
        .progress-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 4px;
            background: #e5e7eb;
            width: 100%;
        }
        
        .progress-fill {
            height: 100%;
            background: #6366f1;
            width: 0%;
            transition: width 0.1s linear;
        }

        /* 标签样式 (用于Canvas覆盖层，如果需要更复杂的排版) */
        .label {
            position: absolute;
            font-size: 14px;
            color: #9ca3af;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

    </style>
</head>
<body>

    <div id="container">
        <canvas id="stage" width="1280" height="720"></canvas>
        
        <div class="subtitle-container" id="subs">
            <div class="subtitle-cn"></div>
            <div class="subtitle-en"></div>
        </div>

        <div class="progress-bar">
            <div class="progress-fill" id="progress"></div>
        </div>
    </div>

<script>
/**
 * 动画引擎与逻辑
 * 
 * 核心思想：
 * 1. 定义时间轴和场景。
 * 2. 每一帧根据当前时间绘制对应的元素状态。
 * 3. 使用插值函数(Lerp)实现平滑运动。
 */

const canvas = document.getElementById('stage');
const ctx = canvas.getContext('2d');
const subCn = document.querySelector('.subtitle-cn');
const subEn = document.querySelector('.subtitle-en');
const progressFill = document.getElementById('progress');

// --- 配置参数 ---
const COLORS = {
    bg: '#ffffff',
    gridEmpty: '#f3f4f6',
    gridActive: '#1f2937', // 输入的黑色像素
    highlight: '#6366f1', // 卷积核颜色 (Indigo)
    featureMap: '#818cf8', // 特征图颜色
    poolMap: '#34d399',    // 池化层颜色 (Emerald)
    flatLayer: '#f472b6',  // 全连接层颜色 (Pink)
    output: '#fbbf24',     // 输出颜色 (Amber)
    text: '#374151',
    line: '#d1d5db'
};

// 手写数字 "7" 的 10x10 像素数据 (简化版)
const INPUT_GRID_SIZE = 10;
const INPUT_DATA = [
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,1,1,1,1,1,1,0,0],
    [0,0,1,1,1,1,1,1,1,0],
    [0,0,0,0,0,0,0,1,1,0],
    [0,0,0,0,0,0,1,1,0,0],
    [0,0,0,0,0,1,1,0,0,0],
    [0,0,0,0,1,1,0,0,0,0],
    [0,0,0,1,1,0,0,0,0,0],
    [0,0,1,1,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0]
];

// 时间轴配置 (单位：秒)
const TIMELINE = {
    totalDuration: 42,
    scenes: {
        intro: { start: 0, end: 6 },
        conv: { start: 6, end: 18 },
        pool: { start: 18, end: 26 },
        fc: { start: 26, end: 34 },
        result: { start: 34, end: 42 }
    }
};

// 字幕脚本
const SCRIPTS = [
    { t: 0, dur: 3, cn: "计算机是如何“看见”图像的？", en: "How do computers 'see' images?" },
    { t: 3, dur: 3, cn: "对计算机而言，图片只是一个由数字组成的网格。", en: "To a computer, an image is just a grid of numbers." },
    { t: 6, dur: 4, cn: "第一步：卷积层。这是CNN的核心。", en: "Step 1: The Convolution Layer. This is the core of CNN." },
    { t: 10, dur: 5, cn: "像手电筒一样，卷积核扫描图像，提取边缘等特征。", en: "Like a flashlight, the kernel scans the image to extract features." },
    { t: 15, dur: 3, cn: "这一过程生成了“特征图”。", en: "This process generates a 'Feature Map'." },
    { t: 18, dur: 4, cn: "第二步：池化层。它负责压缩数据。", en: "Step 2: The Pooling Layer. It compresses the data." },
    { t: 22, dur: 4, cn: "保留最重要的特征，减小计算量，防止过拟合。", en: "Keeping important features while reducing complexity." },
    { t: 26, dur: 4, cn: "第三步：全连接层。将二维特征拉平。", en: "Step 3: Fully Connected Layer. Flattening the 2D features." },
    { t: 30, dur: 4, cn: "神经网络根据这些特征组合进行最终思考。", en: "The network thinks based on these combined features." },
    { t: 34, dur: 4, cn: "最后，输出层给出分类结果。", en: "Finally, the output layer gives the classification." },
    { t: 38, dur: 4, cn: "这就是卷积神经网络的工作原理。", en: "This is how a Convolutional Neural Network works." }
];

let startTime = null;
let isPlaying = true;

// --- 绘图辅助函数 ---

function drawRoundedRect(x, y, w, h, r, color, fill = true, glow = false) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
    
    if (glow) {
        ctx.shadowBlur = 15;
        ctx.shadowColor = color;
    } else {
        ctx.shadowBlur = 0;
    }

    if (fill) {
        ctx.fillStyle = color;
        ctx.fill();
    } else {
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.stroke();
    }
    ctx.shadowBlur = 0; // Reset
}

function drawGrid(data, startX, startY, cellSize, gap, activeColor, opacity = 1) {
    ctx.globalAlpha = opacity;
    for (let i = 0; i < data.length; i++) {
        for (let j = 0; j < data[i].length; j++) {
            const x = startX + j * (cellSize + gap);
            const y = startY + i * (cellSize + gap);
            const val = data[i][j];
            const color = val > 0 ? activeColor : COLORS.gridEmpty;
            
            // 简单的呼吸效果
            const scale = val > 0 ? 1 : 0.9;
            const offset = (cellSize - cellSize * scale) / 2;
            
            drawRoundedRect(x + offset, y + offset, cellSize * scale, cellSize * scale, 4, color);
        }
    }
    ctx.globalAlpha = 1;
}

function drawLine(x1, y1, x2, y2, color, width = 1, dash = []) {
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.strokeStyle = color;
    ctx.lineWidth = width;
    ctx.setLineDash(dash);
    ctx.stroke();
    ctx.setLineDash([]);
}

function drawText(text, x, y, size, color, align = "center") {
    ctx.font = `bold ${size}px Inter, sans-serif`;
    ctx.fillStyle = color;
    ctx.textAlign = align;
    ctx.fillText(text, x, y);
}

// 缓动函数
function easeInOutCubic(x) {
    return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2;
}

function lerp(start, end, t) {
    return start * (1 - t) + end * t;
}

// --- 场景渲染逻辑 ---

function render(timestamp) {
    if (!startTime) startTime = timestamp;
    const elapsed = (timestamp - startTime) / 1000; // 秒
    
    if (elapsed > TIMELINE.totalDuration) {
        // 循环播放或停止
        startTime = timestamp; // Loop
    }

    // 更新UI
    progressFill.style.width = `${(elapsed / TIMELINE.totalDuration) * 100}%`;
    updateSubtitles(elapsed);

    // 清空画布
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = COLORS.bg;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // 场景状态计算
    const tIntro = Math.min(Math.max((elapsed - TIMELINE.scenes.intro.start) / (TIMELINE.scenes.intro.end - TIMELINE.scenes.intro.start), 0), 1);
    const tConv = Math.min(Math.max((elapsed - TIMELINE.scenes.conv.start) / (TIMELINE.scenes.conv.end - TIMELINE.scenes.conv.start), 0), 1);
    const tPool = Math.min(Math.max((elapsed - TIMELINE.scenes.pool.start) / (TIMELINE.scenes.pool.end - TIMELINE.scenes.pool.start), 0), 1);
    const tFc = Math.min(Math.max((elapsed - TIMELINE.scenes.fc.start) / (TIMELINE.scenes.fc.end - TIMELINE.scenes.fc.start), 0), 1);
    const tRes = Math.min(Math.max((elapsed - TIMELINE.scenes.result.start) / (TIMELINE.scenes.result.end - TIMELINE.scenes.result.start), 0), 1);

    // 布局常量
    const inputSize = 25;
    const inputGap = 3;
    const gridW = INPUT_GRID_SIZE * (inputSize + inputGap);
    
    // 动态位置
    // 输入网格从中心移动到左侧
    let inputX = canvas.width/2 - gridW/2;
    let inputY = canvas.height/2 - gridW/2;
    
    if (tConv > 0) {
        inputX = lerp(canvas.width/2 - gridW/2, 150, easeInOutCubic(Math.min(tConv * 3, 1))); // 快速移动到左侧
    }

    // 绘制标题
    if (tIntro < 1) {
        ctx.globalAlpha = 1 - tConv;
        drawText("INPUT IMAGE (28x28 Pixels)", inputX + gridW/2, inputY - 30, 16, COLORS.text);
        ctx.globalAlpha = 1;
    }

    // 1. 绘制输入层
    drawGrid(INPUT_DATA, inputX, inputY, inputSize, inputGap, COLORS.gridActive);

    // 2. 卷积层动画
    if (tConv > 0 && tPool < 1) {
        const featureMapSize = 8; // 假设卷积核3x3, stride 1, padding 0 -> 10-3+1 = 8
        const fmCellSize = inputSize;
        const fmX = inputX + 400;
        const fmY = inputY + (gridW - (featureMapSize*(fmCellSize+inputGap)))/2;

        // 标题
        ctx.globalAlpha = Math.min(tConv * 2, 1);
        drawText("CONVOLUTION (Feature Extraction)", fmX + (featureMapSize*fmCellSize)/2, fmY - 30, 16, COLORS.highlight);
        ctx.globalAlpha = 1;

        // 扫描动画逻辑
        // 模拟扫描过程：总共扫描 8x8 = 64步
        // 在 tConv 0.2 到 0.9 之间完成扫描
        const scanProgress = Math.max(0, Math.min((tConv - 0.2) / 0.7, 1));
        const totalSteps = 64;
        const currentStep = Math.floor(scanProgress * totalSteps);
        
        const kernelSize = 3;
        const kRow = Math.floor(currentStep / featureMapSize);
        const kCol = currentStep % featureMapSize;

        // 绘制卷积核 (在输入图上)
        if (scanProgress < 1 && scanProgress > 0) {
            const kX = inputX + kCol * (inputSize + inputGap);
            const kY = inputY + kRow * (inputSize + inputGap);
            const kW = kernelSize * (inputSize + inputGap) - inputGap;
            
            drawRoundedRect(kX - 4, kY - 4, kW + 8, kW + 8, 6, COLORS.highlight, false, true); // 边框高亮
            
            // 绘制连接线
            const fmTargetX = fmX + kCol * (fmCellSize + inputGap) + fmCellSize/2;
            const fmTargetY = fmY + kRow * (fmCellSize + inputGap) + fmCellSize/2;
            
            ctx.globalAlpha = 0.3;
            drawLine(kX + kW, kY, fmTargetX, fmTargetY - fmCellSize/2, COLORS.highlight, 1);
            drawLine(kX + kW, kY + kW, fmTargetX, fmTargetY + fmCellSize/2, COLORS.highlight, 1);
            ctx.globalAlpha = 1;
        }

        // 绘制特征图 (Feature Map)
        // 构建逐渐填充的特征图数据
        let featureData = [];
        for(let r=0; r<featureMapSize; r++) {
            let row = [];
            for(let c=0; c<featureMapSize; c++) {
                let stepIndex = r * featureMapSize + c;
                // 简单的逻辑：如果输入对应区域有像素，特征图就亮
                // 这里简化模拟，直接用某种模式
                let val = 0;
                if (stepIndex <= currentStep) {
                     // 模拟提取边缘：这里简单硬编码一些亮的点
                     if (r > 1 && r < 7 && c > 1 && c < 6) val = 1;
                }
                row.push(val);
            }
            featureData.push(row);
        }
        
        ctx.globalAlpha = Math.min(tConv * 2, 1);
        drawGrid(featureData, fmX, fmY, fmCellSize, inputGap, COLORS.featureMap);
        ctx.globalAlpha = 1;
    }

    // 3. 池化层动画
    if (tPool > 0 && tFc < 1) {
        // 特征图位置
        const fmX = inputX + 400; 
        const featureMapSize = 8;
        const fmCellSize = inputSize;
        const fmY = inputY + (gridW - (featureMapSize*(fmCellSize+inputGap)))/2;

        // 池化图位置 (Max Pooling 2x2 -> 4x4)
        const poolSize = 4;
        const poolCellSize = inputSize; // 视觉上保持大小，或者稍微变大
        const poolX = fmX + 350;
        const poolY = inputY + (gridW - (poolSize*(poolCellSize+inputGap)))/2;
        
        // 池化过程：输入淡出，池化图淡入，并有线条连接
        const poolProgress = Math.min(tPool * 1.5, 1); // 快速进入

        // 绘制之前的特征图 (逐渐变透明)
        let staticFeatureData = []; // 完整特征图
        for(let r=0; r<8; r++) {
            let row = [];
            for(let c=0; c<8; c++) row.push((r > 1 && r < 7 && c > 1 && c < 6)?1:0);
            staticFeatureData.push(row);
        }
        
        if (tPool < 0.8) {
             drawGrid(staticFeatureData, fmX, fmY, fmCellSize, inputGap, COLORS.featureMap, 1 - tPool);
             drawText("POOLING (Downsampling)", poolX + (poolSize*poolCellSize)/2, poolY - 30, 16, COLORS.poolMap);
        }

        // 绘制池化后的图
        let poolData = [
            [0,0,0,0],
            [0,1,1,0],
            [0,1,1,0],
            [0,0,0,0]
        ]; // 4x4
        
        ctx.globalAlpha = poolProgress;
        drawGrid(poolData, poolX, poolY, poolCellSize, inputGap, COLORS.poolMap);

        // 演示 2x2 -> 1x1 的连接线 (仅展示一组)
        if (tPool > 0.2 && tPool < 0.8) {
             // 源区域 (2,2) - (3,3)
             const srcX = fmX + 2*(fmCellSize+inputGap);
             const srcY = fmY + 2*(fmCellSize+inputGap);
             const srcW = 2*(fmCellSize+inputGap) - inputGap;
             
             drawRoundedRect(srcX, srcY, srcW, srcW, 4, COLORS.poolMap, false, true);

             // 目标区域 (1,1)
             const dstX = poolX + 1*(poolCellSize+inputGap);
             const dstY = poolY + 1*(poolCellSize+inputGap);
             
             ctx.beginPath();
             ctx.moveTo(srcX + srcW, srcY + srcW/2);
             ctx.lineTo(dstX, dstY + poolCellSize/2);
             ctx.strokeStyle = COLORS.poolMap;
             ctx.stroke();
        }
        ctx.globalAlpha = 1;
    }

    // 4. 全连接层动画
    if (tFc > 0) {
        const poolX = inputX + 400 + 350; // 上一步的位置
        const poolY = inputY + (gridW - (4*(inputSize+inputGap)))/2;
        
        // 扁平化：4x4 矩阵变成 1x16 列向量
        // 动画：矩阵粒子飞向一列
        
        const flatX = poolX + 250;
        const flatYBase = canvas.height/2 - (10 * 18) / 2; // 10个代表节点
        
        // 标题
        ctx.globalAlpha = Math.min(tFc * 2, 1);
        drawText("FULLY CONNECTED", flatX, flatYBase - 40, 16, COLORS.flatLayer);
        
        // 绘制扁平化节点
        const fcNodes = 10; // 简化展示10个节点
        for(let i=0; i<fcNodes; i++) {
            const nodeX = flatX;
            const nodeY = flatYBase + i * 25;
            
            // 动画：从池化层飞过来
            let curX = nodeX;
            let curY = nodeY;
            
            if (tFc < 0.5) {
                // 飞入阶段
                const flyT = easeInOutCubic(tFc * 2);
                // 起点大致在池化层中心
                curX = lerp(poolX + 50, nodeX, flyT);
                curY = lerp(poolY + 50, nodeY, flyT);
            }
            
            ctx.beginPath();
            ctx.arc(curX, curY, 6, 0, Math.PI*2);
            ctx.fillStyle = (i > 2 && i < 8) ? COLORS.flatLayer : '#e5e7eb'; // 中间几个亮一点
            ctx.fill();
        }

        // 绘制输出层 (0-9)
        const outX = flatX + 200;
        const outYBase = flatYBase;
        
        if (tFc > 0.5) {
            drawText("OUTPUT", outX + 20, outYBase - 40, 16, COLORS.output);
            const connectT = Math.min((tFc - 0.5) * 2, 1); // 连接线透明度
            
            for(let i=0; i<10; i++) {
                const nodeX = outX;
                const nodeY = outYBase + i * 25;
                
                // 绘制连接线 (FC -> Output)
                if (connectT > 0) {
                    ctx.globalAlpha = connectT * 0.1; // 淡
                    // 画几条线意思一下，全画太乱
                    if (i === 7) {
                        // 连接到7的线亮一点
                        ctx.globalAlpha = connectT * 0.5;
                        ctx.strokeStyle = COLORS.output;
                    } else {
                        ctx.strokeStyle = COLORS.line;
                    }
                    
                    // 从FC层每个点连过来
                    for(let j=0; j<fcNodes; j++) {
                        if (Math.abs(i - j) < 3) { // 只画附近的线，优化视觉
                             ctx.beginPath();
                             ctx.moveTo(flatX, flatYBase + j * 25);
                             ctx.lineTo(nodeX, nodeY);
                             ctx.stroke();
                        }
                    }
                }
                
                ctx.globalAlpha = 1;
                // 绘制输出节点
                ctx.beginPath();
                ctx.arc(nodeX, nodeY, 8, 0, Math.PI*2);
                
                // 结果展示阶段
                if (tRes > 0 && i === 7) {
                    // 最终结果 "7" 高亮
                    const glow = Math.sin(elapsed * 5) * 0.5 + 0.5; // 呼吸
                    ctx.shadowColor = COLORS.output;
                    ctx.shadowBlur = 10 + glow * 10;
                    ctx.fillStyle = COLORS.output;
                } else {
                    ctx.fillStyle = '#e5e7eb';
                    ctx.shadowBlur = 0;
                }
                ctx.fill();
                ctx.shadowBlur = 0;

                // 数字标签
                ctx.fillStyle = '#6b7280';
                ctx.font = '12px Inter';
                ctx.textAlign = 'left';
                ctx.fillText(i, nodeX + 15, nodeY + 4);
                
                // 概率条 (仅在结果阶段)
                if (tRes > 0) {
                    let prob = 0.05;
                    if (i === 7) prob = 0.92;
                    if (i === 1) prob = 0.1;
                    
                    // 动态增长
                    const barW = prob * 50 * Math.min(tRes * 3, 1);
                    ctx.fillStyle = i===7 ? COLORS.output : '#e5e7eb';
                    ctx.fillRect(nodeX + 30, nodeY - 4, barW, 8);
                    
                    if (i === 7 && tRes > 0.5) {
                        ctx.fillStyle = COLORS.output;
                        ctx.font = 'bold 14px Inter';
                        ctx.fillText("92%", nodeX + 90, nodeY + 4);
                    }
                }
            }
        }
    }

    requestAnimationFrame(render);
}

// 字幕更新逻辑
function updateSubtitles(time) {
    const script = SCRIPTS.find(s => time >= s.t && time < s.t + s.dur);
    if (script) {
        if (subCn.innerText !== script.cn) {
            subCn.style.opacity = 0;
            subEn.style.opacity = 0;
            setTimeout(() => {
                subCn.innerText = script.cn;
                subEn.innerText = script.en;
                subCn.style.opacity = 1;
                subEn.style.opacity = 1;
            }, 200); // 淡入淡出
        }
    } else {
        // 没有字幕时留白或保持上一句(这里选择淡出)
        // subCn.style.opacity = 0;
        // subEn.style.opacity = 0;
    }
}

// 启动动画
requestAnimationFrame(render);

</script>
</body>
</html>
